#include <iostream>
using namespace std;
 
struct Node                         //Звено дерева
{
   int x;                           //То, что записываем в дерево
   Node *l,*r;                      //Это указатели на новые звенья
};
 
void show(Node *&Tree)              //Функция обхода
{
	if (Tree != NULL)               //Пока не встретится пустое звено
	{
	   show(Tree->l);               //Рекурсивная функция для вывода левого поддерева
	   cout << Tree->x << '\t';               //Отображаем корень дерева
	   show(Tree->r);               //Рекурсивная функци для вывода правого поддерева
	}
}
 
/*Добавили очистку памяти*/
void del(Node *&Tree){
   if (Tree != NULL)                //Пока не встретится пустое звено
	{
	   del(Tree->l);                //Рекурсивная функция прохода по левому поддереву
	   del(Tree->r);                //Рекурсивная функци для прохода по правому поддереву
	   delete Tree;                 //Убиваем конечный элемент дерева
	   Tree = NULL;                
	}
 
}
 
void add_node(int x,Node *&MyTree) //Фукция добавления звена в дерево
{
	if (NULL == MyTree)             //Закладываем семя дерева
	{
		MyTree = new Node;          //Выделяем память под звено дерева
		MyTree->x = x;              //Записываем данные в звено
		MyTree->l = MyTree->r = NULL; //Подзвенья инициализируем пустотой во избежание ошибок
	}
 
                   if (x < MyTree->x)   //Если нововведенный элемент x меньше чем элемент x из семечка дерева, уходим влево
                      {
                          if (MyTree->l != NULL) add_node(x, MyTree->l); //При помощи рекурсии заталкиваем элемент на свободный участок
                          else          //Если элемент получил свой участок, то
                          {
                              MyTree->l = new Node;                 //Выделяем память левому подзвену. Именно подзвену, а не просто звену
                              MyTree->l->l = MyTree->l->r = NULL;   //У левого подзвена будут свои левое и правое подзвенья, инициализируем их пустотой
                              MyTree->l->x = x;                     //Записываем в левое подзвено записываемый элемент
                          }
                      }
 
                    if (x > MyTree->x)              //Если нововведенный элемент x больше чем элемент x из семечка дерева, уходим вправо
                      {
                          if (MyTree->r != NULL) add_node(x, MyTree->r); //При помощи рекурсии заталкиваем элемент на свободный участок
                          else              //Если элемент получил свой участок, то
                          {
                              MyTree->r = new Node;                 //Выделяем память правому подзвену. Именно подзвену, а не просто звену
                              MyTree->r->l = MyTree->r->r = NULL;   //У правого подзвена будут свои левое и правое подзвенья, инициализируем их пустотой
                              MyTree->r->x = x;                     //Записываем в правое подзвено записываемый элемент
                          }
                      }
}
 
int main()
{
   Node *Tree = NULL;                   //Указатель, тип которого = звено дерева и инициализирую его пустотой
	  for (int i=5; i>0; i--) add_node(i,Tree);       //
	  show(Tree);                        //Вывод на экран дерева. или просто обход дерева
	  cout << '\n';
	  del(Tree);                        //Чистка памяти! Распилили дерево
 
	  for (int i=20; i>5; i--) add_node(i,Tree);        //На месте спиленного дерева можно растить новое
	  show(Tree);                       //Смотрим, что выросло
	  del(Tree);                        //Когда дерево уже не нужно, зачищаем память
}
